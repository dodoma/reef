# $make ... RELEASE=1 可生成执行更快速的代码（例如, hash table 操作速度有3倍以上差异），
# 并且可以发现程序中隐含的bug
RELEASE = 1

OS := $(shell echo $(shell uname -s) | tr '[A-Z]' '[a-z]')
MACHINE := $(shell echo $(shell uname -m) | tr '[A-Z]' '[a-z]')

CC = gcc
AR = ar
TAR = tar
MAKE = make
RANLIB = ranlib

MULTIMAKE = $(BASEDIR)/tools/multimake.sh
CPWITHDIR = $(BASEDIR)/tools/cpwithdir.sh

INCBASE = -I $(BASEDIR)/include/ -I /usr/local/include
# reef used other's function, so, reef first
LIBBASE = -L $(BASEDIR)/src/ -L /usr/local/lib -lreef -lpthread

ifeq ($(OS), linux)
LIBBASE += -lrt -lbsd
endif

# C99 new features:
# 1. variadic macros
#   e.g. #define eprintf(format, ...) printf(stderr, format, ##__VA_ARGS__)
# 2. declare variables at locations other than the start of a block
#   e.g. for (int i = 0; i < n; ++i) { ... }
# 3. stdint.h, which defines int8_t, uint8_t, and INT32_MAX...
# 4. new initializer mechanisms
#   e.g. struct { int x, y; } a[10] = { [3] = { .y = 12, .x = 1 } };
# 5. one-line comments beginning with //
# 6. Variable length arrays, e.g. int x, a[x];
# 7. __func__ predefined identifier
# ...
CFLAGS = -std=c99 -D_GNU_SOURCE

# If optimization level is >= 2 in gcc-4.1, strict-aliasing is used,
# and this could cause probelms when a pointer is referencing to a different type
# of object and the object is refered thereafter by using this pointer.
# That is the case in this example.
# So you should force the compiler to not use strict-aliasing
# by a argument "-fno-strict-aliasing" if you want to use "-O2" or "-O3".

ifeq ($(RELEASE), 1)
CFLAGS += -fno-strict-aliasing -O3 -Wall -DRELEASE -Wno-unused-function
else
CFLAGS += -pg -g -Wall -Wno-unused-function
endif

ifeq ($(DEBUG_MSG), 1)
CFLAGS += -DDEBUG_MSG
endif

ifeq ($(USE_MEMCACHE), 1)
CFLAGS += -DUSE_MEMCACHE
LIBBASE += -lmemcached
endif
