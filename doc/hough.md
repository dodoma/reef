## 霍夫变换


### 直线检测

从直线检测说起，图像中有N个白点（特征点），需要找出这些点组成的所有直线
（直线在图中包含的特征点个数越多，排位越靠前）

为了使问题简化，我们通常将图像先进行边缘检测
（因为对图像内部做直线检测既无意义，也耗时间）

我们考虑更加简单点的情况，图像中N个白点，需要找到经过某点 P 的一条最佳直线。
即，经过该点的所有直线中，哪条覆盖了图像中最多的白点？


* 你会如何实现？

遍历图像中的所有白点，计算该点与待测点 P 组成直线与水平方向夹角的正切值（tang: height / width）
所有正切值中，最集中的部分，便为最佳角度。

换句话说，经过该点，沿该角度作线，将有最多的白点落在该线上。


* 再看看霍夫变换

直线在极坐标系可以表示为：

    r = x * cos(theta) + y * sin(theta)

    r 为极轴，theta 为极角

为此，我们假设以45度为一个旋转步长，对图像中的每个白点（假设有三个白点）作如下运算：


点A(12, 23)                点B(15, 43)                  点C(40, 33)

| theta | r    |          | theta | r    |            | theta | r    |
| ----- | ---- |          | ----- | ---- |            | ----- | ---- |
| 0     | 20.8 |          | 0     | 43.2 |            | 0     | 49.8 |
| 45    | 12.5 |          | 45    | 23   |            | 45    | 54.5 |
| 90    | 30   |          | 90    | 43.3 |            | 90    | 36   |
| 135   | 21   |          | 135   | 83   |            | 135   | 23   |

将这些所有结果针对数组下标找对应位置，然后＋1，最后排序，最大值为最适合直线，其值为落点个数。


```c
  int maxr = sqrt(width * width + height * height);
  int theta[4] = {0, 45, 90, 135};
  int r[4][maxr];

  memset(r, 0, sizeof(r));
  for (int i = 0; i < point_num; i++) {
      for (int j = 0; j < 4; j++) {
          dis = (int)(point[i][0] * cos(theta[j]) + point[i][1] * sin(theta));
          r[j][dis]++;
      }
  }

  struct {
      int theta;
      int r;
  } res[100];

  for (int i = 0; i < 100; i++) {
      find_out_max(r);
      res[i].theta = r[x];
      res[i].r = r[y]
  }

  int x, y, maxv = 0;
  for (int i = 0; i < point_num; i++) {
      for (int j = 0; j < maxr; j++) {
          if (maxv < r[i][j]) {
              maxv = r[i][j];
              x = i;
              y = j;
          }
      }
  }
  // theta[x] 极坐标系下，最佳直线的极角, y 为极轴，maxv 为该图片白点落在该直线上点的个数
```
